//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : E-Healthcare-Canada
//  @ File Name : ConnectionManagement.cpp
//  @ Date : 11/9/2010
//  @ Author : 
//
//


#include "include/ConnectionManagement.h"

ConnectionManagement::ConnectionManagement(ListContainer* listContainer)
{
    container = listContainer;

    LoadFile("config.ini");

    loggedIn = false;

    // Read reply
    connect(&socket, SIGNAL(readyRead()), this, SLOT(readReply()));
    // This is initial connect right now
    connect(&socket, SIGNAL(connected()), this, SLOT(sendData()));
    // This is the USER disconnecting right now
    connect(&socket, SIGNAL(disconnected()), this, SLOT(closeConnection()));
    // This is the error if the server is not connecting
    connect(&socket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error(QAbstractSocket::SocketError)));
}

ConnectionManagement::~ConnectionManagement()
{

}

bool ConnectionManagement::LoadFile(QString fileName)
{
    // open the config.ini file to read in the IP:PORT
    QFile file(fileName);
    QStringList tempList;
    QStringList conList;
    if( !file.open( QFile::ReadOnly | QFile::Text ) ) {
        QMessageBox::warning(this, QObject::tr("Application"),
                             QObject::tr( "Cannot read file %1:\n%2.")
                             .arg(fileName)
                             .arg(file.errorString()));
        return false;
    }

    QTextStream in( &file );
    while( !in.atEnd() ) {
        tempList += in.readLine(200);
        qDebug() << "Added IP:PORT into tempList : " << tempList;

        QString sec1 = tempList[0];
        // store the IP AND port into the string
        conList = sec1.split(":");
        IP = conList.at(0);
        qDebug() << "IP: " << IP;

        QString tempPort = conList.at(1);
        PORT = tempPort.toInt();
        qDebug() << "PORT: " << PORT;
    }
    return false;
}

QString ConnectionManagement::getIP() {
    return IP;
}

int ConnectionManagement::getPort() {
    return PORT;
}

ListContainer* ConnectionManagement::getListContainer() {
    return container;
}

void ConnectionManagement::setMsg(QString msgData) {
    msg = msgData;
}

void ConnectionManagement::setSID(int sID) {
    sessionID = sID;
}

void ConnectionManagement::setLoginStatus(bool status) {
    loggedIn = status;
}

void ConnectionManagement::connectToServer()
{
    if (!loggedIn)
    {
        server = new Server(this); // For later
        LoginMsg loginMsg;
        msg = loginMsg.toXML();
        qDebug() << "Connecting to server...";
        socket.connectToHost(IP, PORT); // Right here is the start of all issues!
    } else
        qDebug() << "You are already logged in";
}

bool ConnectionManagement::disconnectedByClient()
{
    if (loggedIn)
    {
        qDebug() << "Connection closed by client, stopped listening";
        LogoutMsg* logoutMsg = new LogoutMsg(sessionID);
        msg = logoutMsg->toXML();
        socket.connectToHost(IP, PORT);
        //while (socket.state() != 3)
            //socket.waitForConnected();
        //sendData();
        //loggedIn = false; // Fix this
        while (socket.state() != 0)
            socket.waitForDisconnected();
        return true;
    }
    qDebug() << "You are not logged in";
    return false;
}

void ConnectionManagement::handleReadUpdateReply(ReadUpdateReply* readReply, UpdateReply* updateReply) {
    container->setRevNum(readReply->getEnd().remove("rev").toInt());
    qDebug()<<"attempting to insert into listcontainer";
    qDebug()<<updateReply->toXML();
    foreach(DiseaseCase* dc, updateReply->getD_Cases())
        container->addDiseaseCase(dc);
    qDebug()<<"inserting disease cases";
    foreach(Supply* s, updateReply->getSupplyUpdates()){
        container->addToSupply(s);

    }
    qDebug()<<"inserting supplies";
    foreach(Shipment* s, updateReply->getShipments())
        container->addShipment(s);
    qDebug()<<"inserting shipments";
    foreach(DiseaseType* dt, updateReply->getD_Types())
        container->addDiseaseType(dt);
    qDebug()<<"inserting disease types";
    foreach(SupplyType* st, updateReply->getS_Types()){
        container->addSupplyType(st);
    //qDebug()<<"inserted supplytype:"<<st->toXML();
    }
    qDebug()<<"inserting supply types";
}

void ConnectionManagement::readReply()
{
    qDebug() << "Reply received";

    QString msg, type;
    QByteArray buffer;

    buffer = socket.readAll();


    msg = buffer;
    qDebug() << msg;
    p.parse(msg);
    type = typeid(*(p.getReply())).name();

    if (type.contains("LoginReply"))
    {
        sessionID = dynamic_cast<LoginReply*>(p.getReply())->getSID();
        loggedIn = true;
        getLatest(0);
        //qDebug()<<"***revision***"<<container->getRevNum();
    } else if (type.contains("LogoutReply"))
    {
        sessionID = NULL;
        loggedIn = false;
        delete server;
    } else if (type.contains("ReadUpdateReply"))
    {
        handleReadUpdateReply(dynamic_cast<ReadUpdateReply*>(p.getReply()), p.getUpdate());
    } else if (type.contains("WriteUpdateReply"))
    {

    }
}

void ConnectionManagement::getLatest(int revisionNumber)
{
    ReadUpdate* readUpdate = new ReadUpdate("sid" + QString::number(sessionID), "rev" + QString::number(revisionNumber));
    msg = readUpdate->toXML();
    //qDebug()<<msg;
    while (socket.state() != 0)
        socket.waitForDisconnected();
    socket.connectToHost(IP, PORT); // Right here is the start of all issues!
}

void ConnectionManagement::sendData()
{
    if (!loggedIn)
        qDebug() << "Probably a first connect";

    qDebug() << "Sending data...";
    QByteArray arr;
    arr = msg.toAscii().append('\0');
    socket.write(arr);

    // Lets make sure the message is sent however this will cause issues with a disconnect I think
    while(socket.bytesToWrite() > 0)
    {
       socket.waitForBytesWritten();
    }
    qDebug() << "Data written";
}

void ConnectionManagement::error(QAbstractSocket::SocketError error)
{
    if (error == 0 && !loggedIn)
    {
        qDebug() << "Stopped listening due to QAbstractSocket Error: 0";
        delete server; // this line should fix login issues
        //loggedIn = false;
        closeConnection();
    } else if (error == 1) {}
    else { qDebug() << error; }
    /*
    else if (error == 1) {
        qDebug() << "Stopped listening due to QAbstractSocket Error: 1";
        delete server; // this line should fix login issue
        //loggedIn = false; // Added this to hopefully account for disconnection
        return;
    }
    */
}

void ConnectionManagement::closeConnection()
{
    qDebug() << "Socket closed";
    socket.close();
}
